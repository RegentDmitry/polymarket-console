"""
Polymarket market data — load crypto markets from Gamma API.

Parses BTC/ETH prediction markets, extracts strike prices and directions.
Uses crypto_markets.json (generated by update_bot) as the primary source.
Prices are fetched in batch via paginated events search.
"""

import json
import re
import ssl
import urllib.request
from dataclasses import dataclass, field
from datetime import datetime, timezone
from pathlib import Path
from threading import Lock
from typing import Dict, List, Optional, Tuple


_ctx = ssl.create_default_context()
_ctx.check_hostname = False
_ctx.verify_mode = ssl.CERT_NONE

GAMMA_API = "https://gamma-api.polymarket.com"


@dataclass
class CryptoMarket:
    """Parsed crypto market from Polymarket."""
    slug: str
    question: str
    currency: str          # "BTC" or "ETH"
    strike: float          # Strike price in USD
    direction: str         # "above" or "below"
    yes_price: float       # Current YES price
    no_price: float        # Current NO price
    end_date: str          # ISO date
    condition_id: str
    yes_token_id: str
    no_token_id: str
    active: bool = True

    @property
    def is_up(self) -> bool:
        return self.direction == "above"

    @property
    def days_remaining(self) -> float:
        try:
            if "T" in self.end_date:
                end = datetime.fromisoformat(self.end_date.replace("Z", "+00:00"))
            else:
                end = datetime.strptime(self.end_date, "%Y-%m-%d").replace(
                    hour=23, minute=59, second=59, tzinfo=timezone.utc
                )
            now = datetime.now(timezone.utc)
            return max(0, (end - now).total_seconds() / 86400)
        except Exception:
            return 0.0

    @property
    def pm_price(self) -> float:
        """Polymarket price for the relevant side (touch probability equivalent)."""
        if self.is_up:
            return self.yes_price
        else:
            return 1 - self.yes_price  # NO side price for "below" = 1 - YES


class PolymarketData:
    """Loads and caches crypto markets from Polymarket."""

    def __init__(self, markets_json: Path = Path("crypto_markets.json")):
        self._lock = Lock()
        self._markets: List[CryptoMarket] = []
        self._last_update: Optional[datetime] = None
        self._markets_json = Path(markets_json) if not isinstance(markets_json, Path) else markets_json

    @property
    def markets(self) -> List[CryptoMarket]:
        with self._lock:
            return list(self._markets)

    @property
    def last_update(self) -> Optional[datetime]:
        with self._lock:
            return self._last_update

    @property
    def age_seconds(self) -> float:
        with self._lock:
            if self._last_update is None:
                return float('inf')
            return (datetime.now(timezone.utc) - self._last_update).total_seconds()

    def update_from_json(self) -> bool:
        """Load markets from crypto_markets.json (generated by update_bot).

        Loads market structure without prices. Filters out expired markets.
        Call refresh_prices() after to get live prices.
        """
        if not self._markets_json.exists():
            return False

        try:
            with open(self._markets_json) as f:
                config = json.load(f)

            now = datetime.now(timezone.utc)
            markets = []
            for slug, info in config.items():
                currency = info.get("currency", "")
                if not currency:
                    continue

                # Skip expired markets
                end_str = info.get("end", "")
                try:
                    if "T" in end_str:
                        end_dt = datetime.fromisoformat(end_str.replace("Z", "+00:00"))
                    else:
                        end_dt = datetime.strptime(end_str, "%Y-%m-%d").replace(
                            hour=23, minute=59, second=59, tzinfo=timezone.utc
                        )
                    if end_dt < now:
                        continue
                except (ValueError, TypeError):
                    pass

                token_ids = info.get("token_ids", {})
                yes_token = token_ids.get("Yes", "")
                no_token = token_ids.get("No", "")

                market = CryptoMarket(
                    slug=slug,
                    question=info.get("question", slug),
                    currency=currency,
                    strike=info.get("strike", 0),
                    direction=info.get("direction", "above"),
                    yes_price=0.0,
                    no_price=0.0,
                    end_date=end_str,
                    condition_id=info.get("condition_id", ""),
                    yes_token_id=yes_token,
                    no_token_id=no_token,
                )
                markets.append(market)

            with self._lock:
                self._markets = markets
                self._last_update = datetime.now(timezone.utc)

            return True
        except Exception:
            return False

    def refresh_prices(self) -> int:
        """Fetch live prices for all loaded markets via batch events search.

        Scans Gamma API events endpoint (paginated) to find crypto markets
        and extract their current prices. Much faster than per-market queries.

        Returns number of markets with prices updated.
        """
        # Build set of slugs we need prices for
        with self._lock:
            slugs_needed = {m.slug for m in self._markets}

        if not slugs_needed:
            return 0

        # Fetch prices from events endpoint (batch)
        slug_prices = self._fetch_all_crypto_prices()

        # Update markets with prices
        updated = 0
        with self._lock:
            for market in self._markets:
                if market.slug in slug_prices:
                    market.yes_price, market.no_price = slug_prices[market.slug]
                    market.active = True
                    updated += 1
                else:
                    # Market not found in API — may be expired or delisted
                    # Keep it but mark inactive if days_remaining <= 0
                    if market.days_remaining <= 0:
                        market.active = False

        return updated

    def _fetch_all_crypto_prices(self) -> Dict[str, Tuple[float, float]]:
        """Fetch prices for all crypto markets via paginated events search.

        Returns dict: slug -> (yes_price, no_price)
        """
        slug_prices: Dict[str, Tuple[float, float]] = {}
        crypto_keywords = ["bitcoin", "btc", "ethereum", "eth"]

        try:
            offset = 0
            batch_size = 500
            while True:
                url = f"{GAMMA_API}/events?closed=false&limit={batch_size}&offset={offset}"
                req = urllib.request.Request(url, headers={"User-Agent": "Mozilla/5.0"})
                resp = urllib.request.urlopen(req, timeout=30, context=_ctx)
                events = json.loads(resp.read())
                if not events:
                    break

                for event in events:
                    title = event.get("title", "").lower()
                    event_slug = event.get("slug", "").lower()
                    combined = f"{title} {event_slug}"

                    if not any(kw in combined for kw in crypto_keywords):
                        continue

                    for m in event.get("markets", []):
                        mslug = m.get("slug", "")
                        try:
                            prices = json.loads(m.get("outcomePrices", "[]"))
                            if prices and len(prices) >= 2:
                                slug_prices[mslug] = (float(prices[0]), float(prices[1]))
                        except Exception:
                            pass

                offset += len(events)
                if len(events) < batch_size:
                    break

        except Exception:
            pass

        return slug_prices

    def update(self) -> bool:
        """Update markets — load from JSON + refresh prices."""
        if self._markets_json.exists():
            ok = self.update_from_json()
            if ok:
                self.refresh_prices()
            return ok
        return self.update_from_api()

    def update_from_api(self, slugs: Optional[List[str]] = None) -> bool:
        """Load markets directly from Gamma API.

        If slugs is None, discovers crypto event slugs automatically.
        Falls back to this when crypto_markets.json doesn't exist.
        """
        if slugs is None:
            slugs = self._discover_crypto_slugs()

        markets = []
        for slug in slugs:
            try:
                url = f"{GAMMA_API}/events?slug={slug}"
                req = urllib.request.Request(url, headers={"User-Agent": "Mozilla/5.0"})
                resp = urllib.request.urlopen(req, timeout=10, context=_ctx)
                data = json.loads(resp.read())
                if not data:
                    continue

                for m in data[0].get("markets", []):
                    if m.get("closed") or not m.get("active"):
                        continue

                    q = m.get("question", "")
                    currency = self._detect_currency(q, slug)
                    if not currency:
                        continue

                    # Parse strike
                    strike = self._parse_strike(q)
                    if strike is None:
                        continue

                    # Parse prices
                    try:
                        prices = json.loads(m.get("outcomePrices", "[]"))
                        yes_price = float(prices[0])
                        no_price = float(prices[1]) if len(prices) > 1 else 1 - yes_price
                    except Exception:
                        continue

                    # Token IDs
                    tokens = m.get("clobTokenIds", "")
                    try:
                        token_list = json.loads(tokens) if isinstance(tokens, str) else tokens
                        yes_token = token_list[0] if len(token_list) > 0 else ""
                        no_token = token_list[1] if len(token_list) > 1 else ""
                    except Exception:
                        yes_token = ""
                        no_token = ""

                    direction = self._parse_direction(q, strike, 0)
                    market = CryptoMarket(
                        slug=m.get("slug", slug),
                        question=q,
                        currency=currency,
                        strike=strike,
                        direction=direction,
                        yes_price=yes_price,
                        no_price=no_price,
                        end_date=m.get("endDateIso", m.get("endDate", "")),
                        condition_id=m.get("conditionId", ""),
                        yes_token_id=yes_token,
                        no_token_id=no_token,
                    )
                    markets.append(market)

            except Exception:
                continue

        with self._lock:
            self._markets = markets
            self._last_update = datetime.now(timezone.utc)

        return len(markets) > 0

    def _discover_crypto_slugs(self) -> List[str]:
        """Discover crypto market slugs from Gamma API search."""
        slugs = []
        keywords = ["bitcoin", "ethereum", "btc", "eth"]
        seen = set()

        for keyword in keywords:
            try:
                url = (
                    f"{GAMMA_API}/events?"
                    f"closed=false&limit=50&tag={keyword}"
                )
                req = urllib.request.Request(url, headers={"User-Agent": "Mozilla/5.0"})
                resp = urllib.request.urlopen(req, timeout=10, context=_ctx)
                data = json.loads(resp.read())

                for event in data:
                    slug = event.get("slug", "")
                    if slug and slug not in seen:
                        title = event.get("title", "").lower()
                        if any(w in title for w in ["price", "hit", "$", "reach", "drop"]):
                            slugs.append(slug)
                            seen.add(slug)
            except Exception:
                continue

        return slugs

    def _detect_currency(self, question: str, slug: str) -> str:
        """Detect BTC or ETH from question/slug."""
        text = (question + " " + slug).lower()
        if any(w in text for w in ["bitcoin", "btc"]):
            return "BTC"
        elif any(w in text for w in ["ethereum", "eth"]):
            return "ETH"
        return ""

    def _parse_direction(self, question: str, strike: float, spot: float) -> str:
        """Determine if this is an above or below market."""
        q_lower = question.lower()
        if any(w in q_lower for w in ["drop below", "fall below", "go below", "dip below", "dip to"]):
            return "below"
        if any(w in q_lower for w in ["hit", "reach", "rise above", "go above", "top"]):
            return "above"
        return "above" if strike > spot else "below"

    def _parse_strike(self, text: str) -> Optional[float]:
        """Parse strike price from question text."""
        # $100k / $100K
        match = re.search(r'\$\s*([\d.]+)\s*[kK]', text)
        if match:
            try:
                return float(match.group(1)) * 1000
            except ValueError:
                pass
        # $100,000 or $100000
        match = re.search(r'\$\s*([\d,]+)', text)
        if match:
            price_str = match.group(1).replace(",", "")
            try:
                val = float(price_str)
                if val >= 100 and not (2020 < val < 2030):
                    return val
            except ValueError:
                pass
        return None

    @staticmethod
    def get_orderbook(token_id: str) -> dict:
        """Fetch orderbook from CLOB API (public, no auth needed).

        Returns dict with 'asks' and 'bids' lists.
        Each entry: {"price": "0.55", "size": "100.0"}
        """
        try:
            url = f"https://clob.polymarket.com/book?token_id={token_id}"
            req = urllib.request.Request(url, headers={"User-Agent": "Mozilla/5.0"})
            resp = urllib.request.urlopen(req, timeout=10, context=_ctx)
            return json.loads(resp.read())
        except Exception:
            return {"asks": [], "bids": []}

    @staticmethod
    def get_usable_liquidity(token_id: str, fair_price: float) -> tuple:
        """Get available liquidity at prices below fair price.

        Returns (best_ask, usable_liquidity_usd, weighted_price).
        usable_liquidity = total $ available at ask prices <= fair_price.
        weighted_price = volume-weighted average ask price across usable levels.
        """
        try:
            ob = PolymarketData.get_orderbook(token_id)
            asks = ob.get("asks", [])
            if not asks:
                return 0.0, 0.0, 0.0

            best_ask = min(float(a["price"]) for a in asks)
            total_size = 0.0
            total_cost = 0.0
            for a in asks:
                price = float(a["price"])
                size = float(a["size"])
                if price <= fair_price:
                    cost = price * size
                    total_size += size
                    total_cost += cost

            weighted_price = total_cost / total_size if total_size > 0 else best_ask
            return best_ask, total_cost, weighted_price
        except Exception:
            return 0.0, 0.0, 0.0

    @staticmethod
    def get_bid_liquidity(token_id: str, min_price: float = 0.0) -> tuple:
        """Get bid-side liquidity for selling.

        Returns (best_bid, usable_liquidity_usd, weighted_bid_price).
        usable_liquidity = total $ of bids at prices >= min_price.
        weighted_bid_price = volume-weighted average bid price.
        """
        try:
            ob = PolymarketData.get_orderbook(token_id)
            bids = ob.get("bids", [])
            if not bids:
                return 0.0, 0.0, 0.0

            best_bid = max(float(b["price"]) for b in bids)
            total_size = 0.0
            total_cost = 0.0
            for b in bids:
                price = float(b["price"])
                size = float(b["size"])
                if price >= min_price:
                    cost = price * size
                    total_size += size
                    total_cost += cost

            weighted_price = total_cost / total_size if total_size > 0 else best_bid
            return best_bid, total_cost, weighted_price
        except Exception:
            return 0.0, 0.0, 0.0

    def get_snapshot(self) -> dict:
        """Get a thread-safe snapshot."""
        with self._lock:
            return {
                "markets": list(self._markets),
                "count": len(self._markets),
                "last_update": self._last_update,
            }
